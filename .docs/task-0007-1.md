# Task 0007-1: Schema & Template Management (SQLite + API)

## Goal
Create persistent storage and an HTTP API to manage prompt templates and JSON schemas used by the AI inference engine, stored in a dedicated SQLite database.

## Motivation
Centralizing templates and schemas enables versioning, auditing, A/B testing, and updates without code deploys. SQLite keeps the implementation simple, embeddable and reproducible.

## Acceptance Criteria
- [ ] Create SQLite migration and schema for templates and schemas
- [ ] Implement CRUD HTTP API for templates and schemas (create/read/update/delete/list)
- [ ] Template records include: id, name, version, template_text, schema_version (nullable), metadata, created_at, updated_at
- [ ] Schema records include: id, version, description, schema_json, created_at, updated_at
- [ ] API endpoints validate input and reject invalid JSON schema payloads
- [ ] Implement an in-memory cache of compiled schemas keyed by version, refreshed on change
- [ ] Integrate with the AI engine so `AnalyzeActivity` can resolve schema by template version
- [ ] Unit and integration tests for DB layer and API handlers
- [ ] Add migration file under `db/migrations/` (e.g. `0002_schemas_templates.sql`)

## Scope
- DB migration and repository layer (SQLite)
- HTTP handlers and routes (API) with existing middleware for auth/authorization
- Schema loader/cache and cache invalidation on update
- Tests: repository unit tests and API handler tests
# Task 0007-1: Schema & Template Management (SQLite + API)

## Goal
Create persistent storage and an HTTP API to manage prompt templates and JSON schemas used by the AI inference engine, backed by SQLite.

## Motivation
Centralizing templates and schemas enables versioning, auditing, A/B testing, and updates without code deploys. SQLite keeps the implementation simple and embeddable.

## Current status (progress)
- [x] Add DB migration `db/migrations/0002_schemas_templates.sql` (creates `ai_schemas` and `ai_templates`).
- [x] Repository layer implemented for schemas and templates under `internal/repository/sqlite` with unit tests.
- [x] Schema loader (`internal/ai/loader.go`) implemented with compile-and-cache behavior and `Reload()` API.
- [x] AI engine (`internal/ai`) wired to use DB schema via Loader for validation.
- [x] `scripts/db_init` updated to apply the new migration and seed an initial `ai_schemas` (v1) and `ai_templates` (activity v1) row.
- [x] Unit tests for repository and loader pass locally.
- [x] CRUD HTTP API for templates and schemas implemented (see `api/ai.go` and `api/routes.go`).
- [x] API endpoints validate incoming schema payloads by compiling with `github.com/qri-io/jsonschema` on write and reject invalid schema JSON.
- [x] HTTP endpoint to reload schemas (cache invalidation) implemented: `POST /v1/ai/schemas/reload` (returns 204 No Content).

## Acceptance Criteria (updated)
- [x] Migration file exists under `db/migrations/0002_schemas_templates.sql`.
- [x] Repository functions (Create/Get/List/Delete) for schemas and templates implemented and tested.
- [x] Loader with in-memory compiled-schema cache implemented; provides `GetSchema(version)` and `Reload()`.
- [x] Engine integration: `AnalyzeActivity` validates model outputs using the Loader and resolves templates from DB.
- [x] CRUD HTTP API for templates and schemas implemented and wired in `api/routes.go` under `/v1/ai`.
- [x] API input validation implemented: schema payloads are compiled/validated on write and invalid payloads are rejected with 400.
- [x] Cache invalidation endpoint present: `POST /v1/ai/schemas/reload` triggers loader reload and returns 204.

## DB Design (SQLite)
Migration: `db/migrations/0002_schemas_templates.sql` (already added)

```sql
CREATE TABLE IF NOT EXISTS ai_schemas (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  version TEXT NOT NULL UNIQUE,
  description TEXT,
  schema_json TEXT NOT NULL,
  created INTEGER NOT NULL DEFAULT (strftime('%s','now')),
  updated INTEGER NOT NULL DEFAULT (strftime('%s','now'))
);

CREATE TABLE IF NOT EXISTS ai_templates (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  version TEXT NOT NULL,
  template_text TEXT NOT NULL,
  schema_version TEXT,
  metadata TEXT,
  created INTEGER NOT NULL DEFAULT (strftime('%s','now')),
  updated INTEGER NOT NULL DEFAULT (strftime('%s','now')),
  UNIQUE(name, version)
);

CREATE INDEX IF NOT EXISTS idx_templates_version ON ai_templates(version);
CREATE INDEX IF NOT EXISTS idx_schemas_version ON ai_schemas(version);
```

## API Contract (examples)

- List schemas
  - GET /v1/ai/schemas
  - Response: [{"id":1,"version":"v1","description":"v1 schema","created":...}]

- Get schema
  - GET /v1/ai/schemas/get?version={version}
  - Query param: `version` (string)
  - Response: {"id":1,"version":"v1","schema_json":{...}}

- Create/Update schema
  - POST /v1/ai/schemas
  - Body: {"version":"v1","description":"...","schema_json": { ... }}
  - Validates `schema_json` is well-formed JSON and compiles it with `github.com/qri-io/jsonschema` on write. Returns 204 No Content on success.

- Reload schemas (cache invalidation)
  - POST /v1/ai/schemas/reload
  - No body. Requires auth. Returns 204 No Content on success.

- Templates
  - Create/Update template: POST /v1/ai/templates
    - Body: {"name":"...","version":"v1","template_text":"...","schema_version":"v1"}
    - Template write is size-limited (64KB) and returns 204 No Content on success.
  - Get template: GET /v1/ai/templates/get?name={name}&version={version}
  - Delete template: DELETE /v1/ai/templates/delete?name={name}&version={version}

Notes: all `/v1` endpoints are protected by JWT middleware where applicable; public endpoints (e.g., `/version`, `/health`) remain open.

## Loader / Cache behavior

- The schema loader compiles JSON Schema documents from DB into an in-memory map[string]*jsonschema.Schema and exposes:
  - GetSchema(version string) (*jsonschema.Schema, bool)
  - Reload(ctx context.Context) error
- The loader is used by the AI engine at runtime for strict validation of model outputs (`AnalyzeActivity` uses loader.GetSchema and ValidateBytes).
- Cache invalidation: `POST /v1/ai/schemas/reload` triggers `Loader.Reload()` and returns 204; handlers also validate and store schemas so the DB and cache remain in sync.

## Integration with AI Engine

- The engine resolves templates and schemas exclusively from the database. If a required template or schema is missing the engine construction fails (fail-fast); this prevents silent acceptance of invalid outputs.
- Templates include an optional `schema_version` pointer; when present the engine will prefer template.schema_version for validation.

## Validation & Security

- Validate `schema_json` on write by compiling with `qri-io/jsonschema` (implemented in `CreateOrUpdateSchemaHandler`).
- Limit template size on write to avoid abuse (64KB enforced in `CreateOrUpdateTemplateHandler`).
- Require authentication/authorization for mutation endpoints (JWT middleware applied to `/v1` subrouter).

## Tests

- Unit tests exist for repository CRUD and loader compile/validation flows. These tests pass locally.
- API handler tests need to be added once the HTTP handlers are implemented.

## Implementation Steps (status)
1. Add migration file `db/migrations/0002_schemas_templates.sql` — Done.
2. Add repository code under `internal/repository/sqlite` to manage templates and schemas — Done.
3. Add a schema loader in `internal/ai/loader.go` with caching APIs — Done.
4. Wire engine to load templates and validate with loader — Done.
5. Update `scripts/db_init` to apply migrations and seed the initial schema and template — Done.
6. Implement HTTP handlers and route wiring (CRUD + validation + reload endpoints) — TODO.
7. Add handler tests and integration tests — TODO.

## Next actions (recommended)
- Implement CRUD HTTP handlers for templates/schemas and validate payloads on write (use `qri-io/jsonschema`).
- Add admin endpoints:
  - POST /admin/reload-schemas — calls Loader.Reload()
  - POST /admin/reload-templates — reloads templates (and optionally updates engine instances)
  - Or a combined POST /admin/reload that refreshes both.
- Seed additional templates as needed or expose an admin UI to manage templates.
- Add integration tests that run against a temporary SQLite DB and verify end-to-end behavior.

## Definition of Done
- Migrations are included and tested locally.
- Repository and loader are implemented and covered by unit tests.
- Engine uses DB templates and schema loader for validation.
- Remaining work: implement the HTTP API and reload endpoints; add handler tests.