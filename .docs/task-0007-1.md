-
```markdown
# Task 0007-1: Schema & Template Management (SQLite + API)

## Goal
Create persistent storage and an HTTP API to manage prompt templates and JSON schemas used by the AI inference engine, stored in a dedicated SQLite database.

## Motivation
Centralizing templates and schemas enables versioning, auditing, A/B testing, and updates without code deploys. SQLite keeps the implementation simple, embeddable and reproducible.

## Acceptance Criteria
- [ ] Create SQLite migration and schema for templates and schemas
- [ ] Implement CRUD HTTP API for templates and schemas (create/read/update/delete/list)
- [ ] Template records include: id, name, version, template_text, schema_version (nullable), metadata, created_at, updated_at
- [ ] Schema records include: id, version, description, schema_json, created_at, updated_at
- [ ] API endpoints validate input and reject invalid JSON schema payloads
- [ ] Implement an in-memory cache of compiled schemas keyed by version, refreshed on change
- [ ] Integrate with the AI engine so `AnalyzeActivity` can resolve schema by template version
- [ ] Unit and integration tests for DB layer and API handlers
- [ ] Add migration file under `db/migrations/` (e.g. `0002_schemas_templates.sql`)

## Scope
- DB migration and repository layer (SQLite)
- HTTP handlers and routes (API) with existing middleware for auth/authorization
- Schema loader/cache and cache invalidation on update
- Tests: repository unit tests and API handler tests

## Estimated Effort
3-5 days

## DB Design (SQLite)

-- migration: `db/migrations/0002_schemas_templates.sql`
```sql
CREATE TABLE IF NOT EXISTS ai_schemas (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  version TEXT NOT NULL UNIQUE,
  description TEXT,
  schema_json TEXT NOT NULL,
  created INTEGER NOT NULL DEFAULT (strftime('%s','now')),
  updated INTEGER NOT NULL DEFAULT (strftime('%s','now'))
);

CREATE TABLE IF NOT EXISTS ai_templates (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  version TEXT NOT NULL,
  template_text TEXT NOT NULL,
  schema_version TEXT,
  metadata TEXT,
  created INTEGER NOT NULL DEFAULT (strftime('%s','now')),
  updated INTEGER NOT NULL DEFAULT (strftime('%s','now')),
  UNIQUE(name, version)
);

CREATE INDEX IF NOT EXISTS idx_templates_version ON ai_templates(version);
CREATE INDEX IF NOT EXISTS idx_schemas_version ON ai_schemas(version);
```

## API Contract (examples)

- List schemas
  - GET /api/v1/ai/schemas
  - Response: [{"id":1,"version":"v1","description":"v1 schema","created":...}]

- Get schema
  - GET /api/v1/ai/schemas/{version}
  - Response: {"id":1,"version":"v1","schema_json":{...}}

- Create/Update schema
  - POST /api/v1/ai/schemas
  - Body: {"version":"v1","description":"...","schema_json": { ... }}
  - Validates `schema_json` is valid JSON and optionally a valid JSON Schema (draft-07)

- CRUD for templates
  - GET/POST/PUT/DELETE /api/v1/ai/templates
  - Template body includes: {"name":"...","version":"v1","template_text":"...","schema_version":"v1"}

## Loader / Cache behavior
- Implement a `schemaLoader` service that loads schemas from the DB into an in-memory map[string]*jsonschema.Schema
- Expose `GetSchema(version string) (*jsonschema.Schema, bool)` and `Reload()` methods
- Invalidate/refresh cache for a version when a schema record is created/updated/deleted
- Optionally add periodic refresh for resilience

## Integration with AI Engine
- Update `internal/ai` parsing to accept an optional `templateVersion` parameter or provide a resolver that maps template version â†’ schema
- Prefer the template's configured `schema_version` when validating model output; fall back to the `version` field in the model response only when appropriate

## Validation & Security
- Validate `schema_json` is well-formed JSON on write. Compile it with `github.com/qri-io/jsonschema` to ensure it's a valid JSON Schema.
- Limit template size (for example, 64KB) to prevent abuse
- Require authentication/authorization for mutation endpoints (reuse existing middleware)

## Tests
- Unit tests for repository functions (insert, update, get by version)
- Handler tests for each API route (happy path and validation failures)
- Loader tests to ensure compiled schemas validate expected payloads

## Implementation Steps (high level)
1. Create migration file `db/migrations/0002_schemas_templates.sql` with the SQL above
2. Add repository code under `internal/repository/sqlite` to manage templates and schemas
3. Add a schema loader in `internal/ai/loader.go` with caching APIs
4. Add API handlers in `api/ai_schemas.go` and `api/ai_templates.go`, wire routes in `api/routes.go`
5. Add unit and handler tests, run `go test ./...`
6. Document usage in `README.md` and `.docs`

## Definition of Done
- Migration added and tested locally
- API routes implemented and covered by tests
- Schema loader works and integrates with `internal/ai` parsing
- All new unit tests pass and basic security checks are in place

## Risks & Mitigations
- Schema format mistakes: compile and validate schemas before storing (use the jsonschema library)
- Concurrency: SQLite is file-based; use short transactions and keep write load low. If write traffic grows, consider a server-backed DB.
- Backwards compatibility: prefer fail-fast when a referenced schema is missing to avoid silently accepting invalid model outputs

---

End
```
```